// LLVM IR to TOSA IR Conversion
// Generated by Complete LLVM2TOSA Converter
// Supports all 68 LLVM instructions -> 66 TOSA operations

module {
func.func @matrix_vector_add_broadcast() -> () {
  // Basic block: entry
  // Basic block: function.exit
  func.return
  // Basic block: inner.loop.header
  result_1 = tosa.add scalar_2, scalar_3 : (tensor<1xi32>, tensor<1xi32>) -> tensor<1xi32>
  result_4 = tosa.equal scalar_5, scalar_6 : (tensor<1xi1>, tensor<1xi1>) -> tensor<1xi1>
  result_7 = tosa.add scalar_8, scalar_9 : (tensor<1xi32>, tensor<1xi32>) -> tensor<1xi32>
  // Basic block: inner.loop.latch
  result_10 = tosa.add scalar_11, scalar_12 : (tensor<1xi32>, tensor<1xi32>) -> tensor<1xi32>
  // Basic block: loop.body
  result_14 = tosa.mul scalar_15, scalar_16 : (tensor<1xi32>, tensor<1xi32>) -> tensor<1xi32>
  result_17 = tosa.add scalar_18, scalar_19 : (tensor<1xi32>, tensor<1xi32>) -> tensor<1xi32>
  // GEP: %ptr.A = getelementptr inbounds i32, i32* %A, i32 %matrix.idx
  // Load: %val.A = load i32, i32* %ptr.A
  // GEP: %ptr.B = getelementptr inbounds i32, i32* %B, i32 %j.val
  // Load: %val.B = load i32, i32* %ptr.B
  %sum = tosa.add scalar_22, scalar_23 : (tensor<1xi32>, tensor<1xi32>) -> tensor<1xi32>
  // GEP: %ptr.C = getelementptr inbounds i32, i32* %C, i32 %matrix.idx
  result_24 = tosa.add scalar_5, scalar_25 : (tensor<1xi32>, tensor<1xi32>) -> tensor<1xi32>
  // Basic block: outer.loop.header
  result_27 = tosa.add scalar_28, scalar_29 : (tensor<1xi32>, tensor<1xi32>) -> tensor<1xi32>
  result_30 = tosa.equal scalar_5, scalar_31 : (tensor<1xi1>, tensor<1xi1>) -> tensor<1xi1>
  result_32 = tosa.add scalar_33, scalar_34 : (tensor<1xi32>, tensor<1xi32>) -> tensor<1xi32>
  // Basic block: outer.loop.latch
  result_35 = tosa.add scalar_36, scalar_12 : (tensor<1xi32>, tensor<1xi32>) -> tensor<1xi32>
}

}
