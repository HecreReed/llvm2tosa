// LLVM IR to TOSA IR Conversion
// Generated by Complete LLVM2TOSA Converter
// Supports all 68 LLVM instructions -> 66 TOSA operations

module {
func.func @dot_product() -> () {
  // Basic block: entry
  result_0 = tosa.equal scalar_1, scalar_2 : (tensor<1xi1>, tensor<1xi1>) -> tensor<1xi1>
  result_3 = tosa.add scalar_4, scalar_5 : (tensor<1xi32>, tensor<1xi32>) -> tensor<1xi32>
  // Basic block: loop.body
  // GEP: %a.addr = getelementptr inbounds float, float* %a, i32 %i.val
  // Load: %a.val = load float, float* %a.addr
  // GEP: %b.addr = getelementptr inbounds float, float* %b, i32 %i.val
  // Load: %b.val = load float, float* %b.addr
  result_8 = tosa.mul scalar_9, scalar_10 : (tensor<1xf32>, tensor<1xf32>) -> tensor<1xf32>
  result_11 = tosa.add scalar_12, scalar_13 : (tensor<1xf32>, tensor<1xf32>) -> tensor<1xf32>
  // Basic block: loop.exit
  // Basic block: loop.exit.early
  result_16 = tosa.add scalar_13, scalar_13 : (tensor<1xi32>, tensor<1xi32>) -> tensor<1xi32>
  // Basic block: loop.header
  result_17 = tosa.add scalar_18, scalar_19 : (tensor<1xi32>, tensor<1xi32>) -> tensor<1xi32>
  result_20 = tosa.add scalar_21, scalar_22 : (tensor<1xf32>, tensor<1xf32>) -> tensor<1xf32>
  result_23 = tosa.equal scalar_1, scalar_24 : (tensor<1xi1>, tensor<1xi1>) -> tensor<1xi1>
  result_25 = tosa.add scalar_26, scalar_27 : (tensor<1xi32>, tensor<1xi32>) -> tensor<1xi32>
  // Basic block: loop.latch
  result_28 = tosa.add scalar_29, scalar_30 : (tensor<1xi32>, tensor<1xi32>) -> tensor<1xi32>
}

}
