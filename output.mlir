// LLVM IR to TOSA IR Conversion
// Generated by Complete LLVM2TOSA Converter
// Supports all 68 LLVM instructions -> 66 TOSA operations

module {
  %const_0 = tosa.const {value = dense<1.0> : tensor<1xf32>} : () -> tensor<1xf32>
  %const_1 = tosa.const {value = dense<1.0> : tensor<1xf32>} : () -> tensor<1xf32>
  %const_10 = tosa.const {value = dense<1.0> : tensor<1xf32>} : () -> tensor<1xf32>
  %const_100 = tosa.const {value = dense<1.0> : tensor<1xf32>} : () -> tensor<1xf32>
  %const_12 = tosa.const {value = dense<1.0> : tensor<1xf32>} : () -> tensor<1xf32>
  %const_13 = tosa.const {value = dense<1.0> : tensor<1xf32>} : () -> tensor<1xf32>
  %const_15 = tosa.const {value = dense<1.0> : tensor<1xf32>} : () -> tensor<1xf32>
  %const_17 = tosa.const {value = dense<1.0> : tensor<1xf32>} : () -> tensor<1xf32>
  %const_19 = tosa.const {value = dense<1.0> : tensor<1xf32>} : () -> tensor<1xf32>
  %const_2 = tosa.const {value = dense<1.0> : tensor<1xf32>} : () -> tensor<1xf32>
  %const_20 = tosa.const {value = dense<1.0> : tensor<1xf32>} : () -> tensor<1xf32>
  %const_22 = tosa.const {value = dense<1.0> : tensor<1xf32>} : () -> tensor<1xf32>
  %const_24 = tosa.const {value = dense<1.0> : tensor<1xf32>} : () -> tensor<1xf32>
  %const_26 = tosa.const {value = dense<1.0> : tensor<1xf32>} : () -> tensor<1xf32>
  %const_28 = tosa.const {value = dense<1.0> : tensor<1xf32>} : () -> tensor<1xf32>
  %const_3 = tosa.const {value = dense<1.0> : tensor<1xf32>} : () -> tensor<1xf32>
  %const_30 = tosa.const {value = dense<1.0> : tensor<1xf32>} : () -> tensor<1xf32>
  %const_31 = tosa.const {value = dense<1.0> : tensor<1xf32>} : () -> tensor<1xf32>
  %const_33 = tosa.const {value = dense<1.0> : tensor<1xf32>} : () -> tensor<1xf32>
  %const_35 = tosa.const {value = dense<1.0> : tensor<1xf32>} : () -> tensor<1xf32>
  %const_36 = tosa.const {value = dense<1.0> : tensor<1xf32>} : () -> tensor<1xf32>
  %const_38 = tosa.const {value = dense<1.0> : tensor<1xf32>} : () -> tensor<1xf32>
  %const_4 = tosa.const {value = dense<1.0> : tensor<1xf32>} : () -> tensor<1xf32>
  %const_40 = tosa.const {value = dense<1.0> : tensor<1xf32>} : () -> tensor<1xf32>
  %const_42 = tosa.const {value = dense<1.0> : tensor<1xf32>} : () -> tensor<1xf32>
  %const_43 = tosa.const {value = dense<1.0> : tensor<1xf32>} : () -> tensor<1xf32>
  %const_44 = tosa.const {value = dense<1.0> : tensor<1xf32>} : () -> tensor<1xf32>
  %const_46 = tosa.const {value = dense<1.0> : tensor<1xf32>} : () -> tensor<1xf32>
  %const_47 = tosa.const {value = dense<1.0> : tensor<1xf32>} : () -> tensor<1xf32>
  %const_49 = tosa.const {value = dense<1.0> : tensor<1xf32>} : () -> tensor<1xf32>
  %const_50 = tosa.const {value = dense<1.0> : tensor<1xf32>} : () -> tensor<1xf32>
  %const_52 = tosa.const {value = dense<1.0> : tensor<1xf32>} : () -> tensor<1xf32>
  %const_53 = tosa.const {value = dense<1.0> : tensor<1xf32>} : () -> tensor<1xf32>
  %const_55 = tosa.const {value = dense<1.0> : tensor<1xf32>} : () -> tensor<1xf32>
  %const_56 = tosa.const {value = dense<1.0> : tensor<1xf32>} : () -> tensor<1xf32>
  %const_58 = tosa.const {value = dense<1.0> : tensor<1xf32>} : () -> tensor<1xf32>
  %const_59 = tosa.const {value = dense<1.0> : tensor<1xf32>} : () -> tensor<1xf32>
  %const_6 = tosa.const {value = dense<1.0> : tensor<1xf32>} : () -> tensor<1xf32>
  %const_61 = tosa.const {value = dense<1.0> : tensor<1xf32>} : () -> tensor<1xf32>
  %const_62 = tosa.const {value = dense<1.0> : tensor<1xf32>} : () -> tensor<1xf32>
  %const_64 = tosa.const {value = dense<1.0> : tensor<1xf32>} : () -> tensor<1xf32>
  %const_66 = tosa.const {value = dense<1.0> : tensor<1xf32>} : () -> tensor<1xf32>
  %const_67 = tosa.const {value = dense<1.0> : tensor<1xf32>} : () -> tensor<1xf32>
  %const_69 = tosa.const {value = dense<1.0> : tensor<1xf32>} : () -> tensor<1xf32>
  %const_7 = tosa.const {value = dense<1.0> : tensor<1xf32>} : () -> tensor<1xf32>
  %const_70 = tosa.const {value = dense<1.0> : tensor<1xf32>} : () -> tensor<1xf32>
  %const_72 = tosa.const {value = dense<1.0> : tensor<1xf32>} : () -> tensor<1xf32>
  %const_73 = tosa.const {value = dense<1.0> : tensor<1xf32>} : () -> tensor<1xf32>
  %const_75 = tosa.const {value = dense<1.0> : tensor<1xf32>} : () -> tensor<1xf32>
  %const_76 = tosa.const {value = dense<1.0> : tensor<1xf32>} : () -> tensor<1xf32>
  %const_78 = tosa.const {value = dense<1.0> : tensor<1xf32>} : () -> tensor<1xf32>
  %const_80 = tosa.const {value = dense<1.0> : tensor<1xf32>} : () -> tensor<1xf32>
  %const_81 = tosa.const {value = dense<1.0> : tensor<1xf32>} : () -> tensor<1xf32>
  %const_83 = tosa.const {value = dense<1.0> : tensor<1xf32>} : () -> tensor<1xf32>
  %const_84 = tosa.const {value = dense<1.0> : tensor<1xf32>} : () -> tensor<1xf32>
  %const_86 = tosa.const {value = dense<1.0> : tensor<1xf32>} : () -> tensor<1xf32>
  %const_87 = tosa.const {value = dense<1.0> : tensor<1xf32>} : () -> tensor<1xf32>
  %const_89 = tosa.const {value = dense<1.0> : tensor<1xf32>} : () -> tensor<1xf32>
  %const_9 = tosa.const {value = dense<1.0> : tensor<1xf32>} : () -> tensor<1xf32>
  %const_91 = tosa.const {value = dense<1.0> : tensor<1xf32>} : () -> tensor<1xf32>
  %const_92 = tosa.const {value = dense<1.0> : tensor<1xf32>} : () -> tensor<1xf32>
  %const_94 = tosa.const {value = dense<1.0> : tensor<1xf32>} : () -> tensor<1xf32>
  %const_95 = tosa.const {value = dense<1.0> : tensor<1xf32>} : () -> tensor<1xf32>
  %const_97 = tosa.const {value = dense<1.0> : tensor<1xf32>} : () -> tensor<1xf32>
  %const_98 = tosa.const {value = dense<1.0> : tensor<1xf32>} : () -> tensor<1xf32>

func.func @test_abs() -> () {
  // Basic block: entry
  %is_negative = tosa.greater %const_1, %const_0 : (tensor<1xf32>, tensor<1xf32>) -> tensor<1xi1>
  %neg_input = tosa.sub %const_0, %const_2 : (tensor<1xf32>, tensor<1xf32>) -> tensor<1xf32>
  %result = tosa.select %const_3, %const_4, %is_negative : tensor<1xi1>
}

func.func @test_add() -> () {
  // Basic block: entry
  %result = tosa.add %const_6, %const_7 : (tensor<1xf32>, tensor<1xf32>) -> tensor<1xf32>
}

func.func @test_sub() -> () {
  // Basic block: entry
  %result = tosa.sub %const_9, %const_10 : (tensor<1xf32>, tensor<1xf32>) -> tensor<1xf32>
}

func.func @test_mul() -> () {
  // Basic block: entry
  %result = tosa.mul %const_12, %const_13 : (tensor<1xf32>, tensor<1xf32>) -> tensor<1xf32>
}

func.func @test_negate() -> () {
  // Basic block: entry
  %result = tosa.sub %const_13, %const_15 : (tensor<1xf32>, tensor<1xf32>) -> tensor<1xf32>
}

func.func @test_reciprocal() -> () {
  // Basic block: entry
  %result = tosa.div %const_15, %const_17 : (tensor<1xf32>, tensor<1xf32>) -> tensor<1xf32>
}

func.func @test_rsqrt() -> () {
  // Basic block: entry
  %sqrt_val = tosa.rsqrt %const_19 : tensor<1xf32>
  %sqrt_val_sqrt = tosa.reciprocal %sqrt_val : tensor<1xf32>
  %result = tosa.div %const_19, %const_20 : (tensor<1xf32>, tensor<1xf32>) -> tensor<1xf32>
}

func.func @test_exp() -> () {
  // Basic block: entry
  %result = tosa.exp %const_22 : tensor<1xf32>
}

func.func @test_log() -> () {
  // Basic block: entry
  %result = tosa.log %const_24 : tensor<1xf32>
}

func.func @test_sin() -> () {
  // Basic block: entry
  %result = tosa.sin %const_26 : tensor<1xf32>
}

func.func @test_cos() -> () {
  // Basic block: entry
  %result = tosa.cos %const_28 : tensor<1xf32>
}

func.func @test_tanh() -> () {
  // Basic block: entry
  %pos_exp = tosa.exp %const_30 : tensor<1xf32>
  %neg_input = tosa.sub %const_30, %const_31 : (tensor<1xf32>, tensor<1xf32>) -> tensor<1xf32>
  %neg_exp = tosa.exp %neg_input : tensor<1xf32>
  %numerator = tosa.sub %pos_exp, %neg_exp : (tensor<1xf32>, tensor<1xf32>) -> tensor<1xf32>
  %denominator = tosa.add %pos_exp, %neg_exp : (tensor<1xf32>, tensor<1xf32>) -> tensor<1xf32>
  %result = tosa.div %numerator, %denominator : (tensor<1xf32>, tensor<1xf32>) -> tensor<1xf32>
}

func.func @test_sigmoid() -> () {
  // Basic block: entry
  %neg_input = tosa.sub %const_31, %const_33 : (tensor<1xf32>, tensor<1xf32>) -> tensor<1xf32>
  %exp_neg = tosa.exp %neg_input : tensor<1xf32>
  %one_plus_exp = tosa.add %const_33, %exp_neg : (tensor<1xf32>, tensor<1xf32>) -> tensor<1xf32>
  %result = tosa.div %const_33, %one_plus_exp : (tensor<1xf32>, tensor<1xf32>) -> tensor<1xf32>
}

func.func @test_erf() -> () {
  // Basic block: entry
  %abs_x = tosa.abs %const_35 : tensor<1xf32>
  %t = tosa.div %const_35, %abs_x : (tensor<1xf32>, tensor<1xf32>) -> tensor<1xf32>
  %a1 = tosa.mul %const_36, %t : (tensor<1xf32>, tensor<1xf32>) -> tensor<1xf32>
  %result = tosa.add %const_35, %const_35 : (tensor<1xf32>, tensor<1xf32>) -> tensor<1xf32>
}

func.func @test_floor() -> () {
  // Basic block: entry
  %result = tosa.floor %const_38 : tensor<1xf32>
}

func.func @test_ceil() -> () {
  // Basic block: entry
  %result = tosa.ceil %const_40 : tensor<1xf32>
}

func.func @test_clamp() -> () {
  // Basic block: entry
  %clamped_min = tosa.maximum %const_42, %const_43 : (tensor<1xf32>, tensor<1xf32>) -> tensor<1xf32>
  %result = tosa.minimum %clamped_min, %const_44 : (tensor<1xf32>, tensor<1xf32>) -> tensor<1xf32>
}

func.func @test_maximum() -> () {
  // Basic block: entry
  %result = tosa.maximum %const_46, %const_47 : (tensor<1xf32>, tensor<1xf32>) -> tensor<1xf32>
}

func.func @test_minimum() -> () {
  // Basic block: entry
  %result = tosa.minimum %const_49, %const_50 : (tensor<1xf32>, tensor<1xf32>) -> tensor<1xf32>
}

func.func @test_pow() -> () {
  // Basic block: entry
  %result = tosa.pow %const_52, %const_53 : (tensor<1xf32>, tensor<1xf32>) -> tensor<1xf32>
}

func.func @test_equal() -> () {
  // Basic block: entry
  %result = tosa.equal %const_55, %const_56 : (tensor<1xf32>, tensor<1xf32>) -> tensor<1xi1>
  %result_57 = tosa.add %const_4, %result : (tensor<1xi32>, tensor<1xi32>) -> tensor<1xi32>
}

func.func @test_greater() -> () {
  // Basic block: entry
  %result = tosa.greater %const_58, %const_59 : (tensor<1xf32>, tensor<1xf32>) -> tensor<1xi1>
  %result_60 = tosa.add %const_4, %result : (tensor<1xi32>, tensor<1xi32>) -> tensor<1xi32>
}

func.func @test_greater_equal() -> () {
  // Basic block: entry
  %result = tosa.greater_equal %const_61, %const_62 : (tensor<1xf32>, tensor<1xf32>) -> tensor<1xi1>
  %result_63 = tosa.add %const_4, %result : (tensor<1xi32>, tensor<1xi32>) -> tensor<1xi32>
}

func.func @test_select() -> () {
  // Basic block: entry
  %result = tosa.select %result, %const_4, %const_64 : tensor<1xi1>
}

func.func @test_cast_f32_to_i32() -> () {
  // Basic block: entry
  %result = tosa.add %const_66, %const_67 : (tensor<1xf32>, tensor<1xf32>) -> tensor<1xf32>
  %result_68 = tosa.add %const_67, %result : (tensor<1xi32>, tensor<1xi32>) -> tensor<1xi32>
}

func.func @test_bitwise_and() -> () {
  // Basic block: entry
  %result = tosa.bitwise_and %const_69, %const_70 : (tensor<1xi32>, tensor<1xi32>) -> tensor<1xi32>
  %result_71 = tosa.add %const_67, %result : (tensor<1xi32>, tensor<1xi32>) -> tensor<1xi32>
}

func.func @test_bitwise_or() -> () {
  // Basic block: entry
  %result = tosa.bitwise_or %const_72, %const_73 : (tensor<1xi32>, tensor<1xi32>) -> tensor<1xi32>
  %result_74 = tosa.add %const_67, %result : (tensor<1xi32>, tensor<1xi32>) -> tensor<1xi32>
}

func.func @test_bitwise_xor() -> () {
  // Basic block: entry
  %result = tosa.bitwise_xor %const_75, %const_76 : (tensor<1xi32>, tensor<1xi32>) -> tensor<1xi32>
  %result_77 = tosa.add %const_67, %result : (tensor<1xi32>, tensor<1xi32>) -> tensor<1xi32>
}

func.func @test_bitwise_not() -> () {
  // Basic block: entry
  %result = tosa.bitwise_xor %const_78, %const_4 : (tensor<1xi32>, tensor<1xi32>) -> tensor<1xi32>
  %result_79 = tosa.add %const_67, %result : (tensor<1xi32>, tensor<1xi32>) -> tensor<1xi32>
}

func.func @test_logical_and() -> () {
  // Basic block: entry
  %result = tosa.bitwise_and %const_80, %const_81 : (tensor<1xi1>, tensor<1xi1>) -> tensor<1xi1>
  %result_82 = tosa.add %const_4, %result : (tensor<1xi32>, tensor<1xi32>) -> tensor<1xi32>
}

func.func @test_logical_or() -> () {
  // Basic block: entry
  %result = tosa.bitwise_or %const_83, %const_84 : (tensor<1xi1>, tensor<1xi1>) -> tensor<1xi1>
  %result_85 = tosa.add %const_4, %result : (tensor<1xi32>, tensor<1xi32>) -> tensor<1xi32>
}

func.func @test_logical_xor() -> () {
  // Basic block: entry
  %result = tosa.bitwise_xor %const_86, %const_87 : (tensor<1xi1>, tensor<1xi1>) -> tensor<1xi1>
  %result_88 = tosa.add %const_4, %result : (tensor<1xi32>, tensor<1xi32>) -> tensor<1xi32>
}

func.func @test_logical_not() -> () {
  // Basic block: entry
  %result = tosa.bitwise_xor %const_4, %const_89 : (tensor<1xi1>, tensor<1xi1>) -> tensor<1xi1>
  %result_90 = tosa.add %const_4, %result : (tensor<1xi32>, tensor<1xi32>) -> tensor<1xi32>
}

func.func @test_logical_left_shift() -> () {
  // Basic block: entry
  %result = tosa.logical_left_shift %const_91, %const_92 : (tensor<1xi32>, tensor<1xi32>) -> tensor<1xi32>
  %result_93 = tosa.add %const_67, %result : (tensor<1xi32>, tensor<1xi32>) -> tensor<1xi32>
}

func.func @test_logical_right_shift() -> () {
  // Basic block: entry
  %result = tosa.logical_right_shift %const_94, %const_95 : (tensor<1xi32>, tensor<1xi32>) -> tensor<1xi32>
  %result_96 = tosa.add %const_67, %result : (tensor<1xi32>, tensor<1xi32>) -> tensor<1xi32>
}

func.func @test_arithmetic_right_shift() -> () {
  // Basic block: entry
  %result = tosa.arithmetic_right_shift %const_97, %const_98 : (tensor<1xi32>, tensor<1xi32>) -> tensor<1xi32>
  %result_99 = tosa.add %const_67, %result : (tensor<1xi32>, tensor<1xi32>) -> tensor<1xi32>
}

func.func @test_clz() -> () {
  // Basic block: entry
  %result = tosa.clz %const_100 : tensor<1xi32>
  %result_101 = tosa.add %const_67, %result : (tensor<1xi32>, tensor<1xi32>) -> tensor<1xi32>
}

func.func @test_identity() -> () {
  // Basic block: entry
}

func.func @test_matmul(%A: tensor<?x?xf32>, %B: tensor<?x?xf32>) -> tensor<?x?xf32> {
    // Matrix-matrix multiplication: A * B = C
    %result = tosa.matmul %A, %B : (tensor<?x?xf32>, tensor<?x?xf32>) -> tensor<?x?xf32>
    return %result : tensor<?x?xf32>
  }

func.func @test_conv2d(%input: tensor<1x?x?x1xf32>, %kernel: tensor<?x?x1x1xf32>) -> tensor<1x?x?x1xf32> {
    // 2D Convolution: conv2d(input, kernel)
    %result = tosa.conv2d %input, %kernel : (tensor<1x?x?x1xf32>, tensor<?x?x1x1xf32>) -> tensor<1x?x?x1xf32>
    return %result : tensor<1x?x?x1xf32>
  }

}
