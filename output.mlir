// LLVM IR to TOSA IR Conversion
// Generated by Complete LLVM2TOSA Converter
// Supports all 68 LLVM instructions -> 66 TOSA operations

module {
func.func @blocked_matmul() -> () {
  // Basic block: compute
  %i_k_offset = tosa.mul scalar_0, scalar_1 : (tensor<1xi32>, tensor<1xi32>) -> tensor<1xi32>
  %a_idx = tosa.add %i_k_offset, scalar_2 : (tensor<1xi32>, tensor<1xi32>) -> tensor<1xi32>
  // GEP: %a_ptr = getelementptr float, float* %A, i32 %a_idx
  // Load: %a_val = load float, float* %a_ptr
  %k_j_offset = tosa.mul scalar_3, scalar_4 : (tensor<1xi32>, tensor<1xi32>) -> tensor<1xi32>
  %b_idx = tosa.add %k_j_offset, scalar_5 : (tensor<1xi32>, tensor<1xi32>) -> tensor<1xi32>
  // GEP: %b_ptr = getelementptr float, float* %B, i32 %b_idx
  // Load: %b_val = load float, float* %b_ptr
  %prod = tosa.mul scalar_6, scalar_7 : (tensor<1xf32>, tensor<1xf32>) -> tensor<1xf32>
  %new_sum = tosa.add scalar_8, %prod : (tensor<1xf32>, tensor<1xf32>) -> tensor<1xf32>
  // Basic block: entry
  // Basic block: exit
  func.return
  // Basic block: inner_i
  %i = tosa.add scalar_11, scalar_12 : (tensor<1xi32>, tensor<1xi32>) -> tensor<1xi32>
  %i_limit = tosa.add scalar_13, scalar_14 : (tensor<1xi32>, tensor<1xi32>) -> tensor<1xi32>
  %i_cond = tosa.equal scalar_15, %i : (tensor<1xi1>, tensor<1xi1>) -> tensor<1xi1>
  result_16 = tosa.add scalar_17, scalar_18 : (tensor<1xi32>, tensor<1xi32>) -> tensor<1xi32>
  // Basic block: inner_i_latch
  %i_next = tosa.add %i, scalar_19 : (tensor<1xi32>, tensor<1xi32>) -> tensor<1xi32>
  // Basic block: inner_j
  %j = tosa.add scalar_21, scalar_22 : (tensor<1xi32>, tensor<1xi32>) -> tensor<1xi32>
  %j_limit = tosa.add scalar_23, scalar_24 : (tensor<1xi32>, tensor<1xi32>) -> tensor<1xi32>
  %j_cond = tosa.equal scalar_15, %j : (tensor<1xi1>, tensor<1xi1>) -> tensor<1xi1>
  result_25 = tosa.add scalar_26, scalar_27 : (tensor<1xi32>, tensor<1xi32>) -> tensor<1xi32>
  // Basic block: inner_j_latch
  %i_j_offset = tosa.mul %i, scalar_28 : (tensor<1xi32>, tensor<1xi32>) -> tensor<1xi32>
  %c_idx = tosa.add %i_j_offset, %j : (tensor<1xi32>, tensor<1xi32>) -> tensor<1xi32>
  // GEP: %c_ptr = getelementptr float, float* %C, i32 %c_idx
  result_29 = tosa.add scalar_30, scalar_31 : (tensor<1xi32>, tensor<1xi32>) -> tensor<1xi32>
  %j_next = tosa.add %j, scalar_19 : (tensor<1xi32>, tensor<1xi32>) -> tensor<1xi32>
  // Basic block: inner_k
  %k = tosa.add scalar_33, scalar_34 : (tensor<1xi32>, tensor<1xi32>) -> tensor<1xi32>
  %sum = tosa.add %new_sum, scalar_35 : (tensor<1xf32>, tensor<1xf32>) -> tensor<1xf32>
  %k_limit = tosa.add scalar_36, scalar_37 : (tensor<1xi32>, tensor<1xi32>) -> tensor<1xi32>
  %k_cond = tosa.equal scalar_15, %k : (tensor<1xi1>, tensor<1xi1>) -> tensor<1xi1>
  result_38 = tosa.add scalar_39, scalar_40 : (tensor<1xi32>, tensor<1xi32>) -> tensor<1xi32>
  // Basic block: inner_k_latch
  %k_next = tosa.add %k, scalar_19 : (tensor<1xi32>, tensor<1xi32>) -> tensor<1xi32>
  // Basic block: outer_i
  %bi = tosa.add scalar_42, scalar_43 : (tensor<1xi32>, tensor<1xi32>) -> tensor<1xi32>
  %bi_cond = tosa.equal scalar_15, %bi : (tensor<1xi1>, tensor<1xi1>) -> tensor<1xi1>
  result_44 = tosa.add scalar_45, scalar_46 : (tensor<1xi32>, tensor<1xi32>) -> tensor<1xi32>
  // Basic block: outer_i_latch
  %bi_next = tosa.add %bi, scalar_47 : (tensor<1xi32>, tensor<1xi32>) -> tensor<1xi32>
  // Basic block: outer_j
  %bj = tosa.add scalar_49, scalar_50 : (tensor<1xi32>, tensor<1xi32>) -> tensor<1xi32>
  %bj_cond = tosa.equal scalar_15, %bj : (tensor<1xi1>, tensor<1xi1>) -> tensor<1xi1>
  result_51 = tosa.add scalar_52, scalar_53 : (tensor<1xi32>, tensor<1xi32>) -> tensor<1xi32>
  // Basic block: outer_j_latch
  %bj_next = tosa.add %bj, scalar_54 : (tensor<1xi32>, tensor<1xi32>) -> tensor<1xi32>
  // Basic block: outer_k
  %bk = tosa.add scalar_56, scalar_57 : (tensor<1xi32>, tensor<1xi32>) -> tensor<1xi32>
  %bk_cond = tosa.equal scalar_15, %bk : (tensor<1xi1>, tensor<1xi1>) -> tensor<1xi1>
  result_58 = tosa.add scalar_59, scalar_60 : (tensor<1xi32>, tensor<1xi32>) -> tensor<1xi32>
  // Basic block: outer_k_latch
  %bk_next = tosa.add %bk, scalar_61 : (tensor<1xi32>, tensor<1xi32>) -> tensor<1xi32>
}

}
