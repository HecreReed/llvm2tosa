// LLVM IR to TOSA IR Conversion
// Generated by Complete LLVM2TOSA Converter
// Supports all 68 LLVM instructions -> 66 TOSA operations

module {
func.func @simple_add() -> () {
  // Basic block: entry
  %sum = tosa.add scalar_0, scalar_1 : (tensor<1xi32>, tensor<1xi32>) -> tensor<1xi32>
  result_2 = tosa.add scalar_3, %sum : (tensor<1xi32>, tensor<1xi32>) -> tensor<1xi32>
}

func.func @complex_arithmetic() -> () {
  // Basic block: entry
  %add = tosa.add scalar_4, scalar_5 : (tensor<1xi32>, tensor<1xi32>) -> tensor<1xi32>
  %sub = tosa.sub %add, scalar_6 : (tensor<1xi32>, tensor<1xi32>) -> tensor<1xi32>
  %mul = tosa.mul %sub, scalar_7 : (tensor<1xi32>, tensor<1xi32>) -> tensor<1xi32>
  %div = tosa.int_div %mul, scalar_8 : (tensor<1xi32>, tensor<1xi32>) -> tensor<1xi32>
  result_9 = tosa.add scalar_3, %div : (tensor<1xi32>, tensor<1xi32>) -> tensor<1xi32>
}

func.func @float_math() -> () {
  // Basic block: entry
  %add = tosa.add scalar_10, scalar_11 : (tensor<1xf32>, tensor<1xf32>) -> tensor<1xf32>
  %mul = tosa.mul %add, scalar_12 : (tensor<1xf32>, tensor<1xf32>) -> tensor<1xf32>
  %div = tosa.int_div %mul, scalar_13 : (tensor<1xf32>, tensor<1xf32>) -> tensor<1xf32>
}

func.func @bitwise_ops() -> () {
  // Basic block: entry
  %and_result = tosa.bitwise_and scalar_15, scalar_16 : (tensor<1xi32>, tensor<1xi32>) -> tensor<1xi32>
  %or_result = tosa.bitwise_or %and_result, scalar_17 : (tensor<1xi32>, tensor<1xi32>) -> tensor<1xi32>
  %xor_result = tosa.bitwise_xor %or_result, scalar_18 : (tensor<1xi32>, tensor<1xi32>) -> tensor<1xi32>
  %shl_result = tosa.logical_left_shift %xor_result, scalar_19 : (tensor<1xi32>, tensor<1xi32>) -> tensor<1xi32>
  %shr_result = tosa.arithmetic_right_shift %shl_result, scalar_20 : (tensor<1xi32>, tensor<1xi32>) -> tensor<1xi32>
  result_21 = tosa.add scalar_3, %shr_result : (tensor<1xi32>, tensor<1xi32>) -> tensor<1xi32>
}

func.func @memory_test() -> () {
  // Basic block: entry
  init_22 = tosa.const {value = dense<0> : tensor<1xi32>} : () -> tensor<1xi32>
  result_23 = tosa.add init_22, scalar_24 : (tensor<1xi32>, tensor<1xi32>) -> tensor<1xi32>
  // Load: %loaded = load i32, i32* %ptr, align 4
  %incremented = tosa.add scalar_25, scalar_20 : (tensor<1xi32>, tensor<1xi32>) -> tensor<1xi32>
  result_26 = tosa.add init_22, scalar_24 : (tensor<1xi32>, tensor<1xi32>) -> tensor<1xi32>
  // Load: %final = load i32, i32* %ptr, align 4
  result_27 = tosa.add scalar_3, scalar_28 : (tensor<1xi32>, tensor<1xi32>) -> tensor<1xi32>
}

func.func @comparisons() -> () {
  // Basic block: entry
  %eq = tosa.equal scalar_3, scalar_29 : (tensor<1xi1>, tensor<1xi1>) -> tensor<1xi1>
  %gt = tosa.equal scalar_3, scalar_30 : (tensor<1xi1>, tensor<1xi1>) -> tensor<1xi1>
  %result = tosa.bitwise_and %eq, %gt : (tensor<1xi1>, tensor<1xi1>) -> tensor<1xi1>
  result_31 = tosa.add scalar_20, %result : (tensor<1xi32>, tensor<1xi32>) -> tensor<1xi32>
}

func.func @conditional_select() -> () {
  // Basic block: entry
  %cmp = tosa.equal scalar_3, scalar_32 : (tensor<1xi1>, tensor<1xi1>) -> tensor<1xi1>
  %result = tosa.select %result, scalar_20, %cmp : tensor<1xi1>
  result_33 = tosa.add scalar_3, %result : (tensor<1xi32>, tensor<1xi32>) -> tensor<1xi32>
}

func.func @vector_arithmetic() -> () {
  // Basic block: entry
  %sum = tosa.add scalar_34, scalar_35 : (tensor<1xi32>, tensor<1xi32>) -> tensor<1xi32>
  %diff = tosa.sub %sum, scalar_36 : (tensor<1xi32>, tensor<1xi32>) -> tensor<1xi32>
  result_37 = tosa.add scalar_3, %diff : (tensor<1xi32>, tensor<1xi32>) -> tensor<1xi32>
}

func.func @array_access() -> () {
  // Basic block: entry
  init_38 = tosa.const {value = dense<0> : tensor<1xi32>} : () -> tensor<1xi32>
  // GEP: %ptr0 = getelementptr inbounds [4 x i32], [4 x i32]* %arr, i64 0, i64 0
  result_39 = tosa.add scalar_40, scalar_24 : (tensor<1xi32>, tensor<1xi32>) -> tensor<1xi32>
  // GEP: %ptr1 = getelementptr inbounds [4 x i32], [4 x i32]* %arr, i64 0, i64 1
  result_41 = tosa.add scalar_42, scalar_24 : (tensor<1xi32>, tensor<1xi32>) -> tensor<1xi32>
  // Load: %val0 = load i32, i32* %ptr0, align 4
  // Load: %val1 = load i32, i32* %ptr1, align 4
  %sum = tosa.add scalar_43, scalar_44 : (tensor<1xi32>, tensor<1xi32>) -> tensor<1xi32>
  result_45 = tosa.add scalar_3, %sum : (tensor<1xi32>, tensor<1xi32>) -> tensor<1xi32>
}

func.func @type_conversions() -> () {
  // Basic block: entry
  %ext = tosa.add scalar_46, scalar_3 : (tensor<1xf32>, tensor<1xf32>) -> tensor<1xf32>
  %trunc = tosa.add scalar_47, scalar_3 : (tensor<1xi64>, tensor<1xi64>) -> tensor<1xi64>
  %fp_to_int = tosa.add scalar_48, scalar_3 : (tensor<1xf32>, tensor<1xf32>) -> tensor<1xf32>
  %sum = tosa.add %ext, %trunc : (tensor<1xi32>, tensor<1xi32>) -> tensor<1xi32>
  %result = tosa.add %sum, %fp_to_int : (tensor<1xi32>, tensor<1xi32>) -> tensor<1xi32>
  result_49 = tosa.add scalar_3, %result : (tensor<1xi32>, tensor<1xi32>) -> tensor<1xi32>
}

func.func @function_call() -> () {
  // Basic block: entry
  %doubled = tosa.mul scalar_50, scalar_19 : (tensor<1xi32>, tensor<1xi32>) -> tensor<1xi32>
  // Function call: %result = call i32 @external_func(i32 %doubled)
  result_51 = tosa.add scalar_3, %result : (tensor<1xi32>, tensor<1xi32>) -> tensor<1xi32>
}

func.func @loop_like() -> () {
  // Basic block: continue
  // Basic block: end
  %result = tosa.add scalar_53, scalar_54 : (tensor<1xi32>, tensor<1xi32>) -> tensor<1xi32>
  result_55 = tosa.add scalar_3, %result : (tensor<1xi32>, tensor<1xi32>) -> tensor<1xi32>
  // Basic block: entry
  %cmp = tosa.equal scalar_3, scalar_56 : (tensor<1xi1>, tensor<1xi1>) -> tensor<1xi1>
  result_57 = tosa.add scalar_58, scalar_59 : (tensor<1xi32>, tensor<1xi32>) -> tensor<1xi32>
  // Basic block: loop_body
  %dec = tosa.sub scalar_60, scalar_20 : (tensor<1xi32>, tensor<1xi32>) -> tensor<1xi32>
  %cmp2 = tosa.equal scalar_3, %dec : (tensor<1xi1>, tensor<1xi1>) -> tensor<1xi1>
  result_61 = tosa.add scalar_62, scalar_63 : (tensor<1xi32>, tensor<1xi32>) -> tensor<1xi32>
}

}
