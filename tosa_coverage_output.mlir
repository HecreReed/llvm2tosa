// LLVM IR to TOSA IR Conversion
// Generated by Complete LLVM2TOSA Converter
// Supports all 68 LLVM instructions -> 66 TOSA operations

module {
func.func @test_conv_ops() -> () {
  // Basic block: entry
  func.return
}

func.func @test_arithmetic() -> () {
  // Basic block: entry
  %add_result = tosa.add scalar_0, scalar_1 : (tensor<1xf32>, tensor<1xf32>) -> tensor<1xf32>
  %sub_result = tosa.sub %add_result, scalar_2 : (tensor<1xf32>, tensor<1xf32>) -> tensor<1xf32>
  %mul_result = tosa.mul %sub_result, scalar_3 : (tensor<1xf32>, tensor<1xf32>) -> tensor<1xf32>
  %div_result = tosa.int_div %mul_result, scalar_4 : (tensor<1xf32>, tensor<1xf32>) -> tensor<1xf32>
}

func.func @test_comparisons() -> () {
  // Basic block: entry
  %eq = tosa.equal scalar_6, scalar_7 : (tensor<1xi1>, tensor<1xi1>) -> tensor<1xi1>
  %gt = tosa.equal scalar_6, scalar_8 : (tensor<1xi1>, tensor<1xi1>) -> tensor<1xi1>
  %ge = tosa.equal scalar_6, scalar_9 : (tensor<1xi1>, tensor<1xi1>) -> tensor<1xi1>
  %result = tosa.bitwise_and %eq, %gt : (tensor<1xi1>, tensor<1xi1>) -> tensor<1xi1>
  result_10 = tosa.add scalar_11, %result : (tensor<1xi32>, tensor<1xi32>) -> tensor<1xi32>
}

func.func @test_math_functions() -> () {
  // Basic block: entry
  // Function call: %abs_result = call float @llvm.fabs.f32(float %x)
  // Function call: %exp_result = call float @llvm.exp.f32(float %abs_result)
  // Function call: %log_result = call float @llvm.log.f32(float %exp_result)
  // Function call: %sin_result = call float @llvm.sin.f32(float %log_result)
  // Function call: %cos_result = call float @llvm.cos.f32(float %sin_result)
}

func.func @test_control_flow() -> () {
  // Basic block: entry
  result_13 = tosa.add scalar_14, scalar_15 : (tensor<1xi32>, tensor<1xi32>) -> tensor<1xi32>
  // Basic block: false_branch
  %false_result = tosa.mul scalar_16, scalar_15 : (tensor<1xf32>, tensor<1xf32>) -> tensor<1xf32>
  // Basic block: merge
  %result = tosa.add %false_result, scalar_18 : (tensor<1xf32>, tensor<1xf32>) -> tensor<1xf32>
  // Basic block: true_branch
  %true_result = tosa.mul scalar_20, scalar_18 : (tensor<1xf32>, tensor<1xf32>) -> tensor<1xf32>
}

func.func @test_memory_ops() -> () {
  // Basic block: entry
  init_22 = tosa.const {value = dense<0> : tensor<1xf32>} : () -> tensor<1xf32>
  // Load: %loaded = load float, float* %ptr
  result_23 = tosa.add scalar_24, init_22 : (tensor<1xi32>, tensor<1xi32>) -> tensor<1xi32>
  %result = %result
}

func.func @test_vector_ops() -> () {
  // Basic block: entry
  %elem = tosa.add scalar_6, scalar_24 : (tensor<1xf32>, tensor<1xf32>) -> tensor<1xf32>
  %inserted = tosa.add scalar_6, scalar_11 : (tensor<1xf32>, tensor<1xf32>) -> tensor<1xf32>
  result_26 = tosa.add scalar_27, %inserted : (tensor<1xi32>, tensor<1xi32>) -> tensor<1xi32>
}

}
